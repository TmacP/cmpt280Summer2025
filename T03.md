# CMPT 280 - Tutorial: Arrayed Binary Trees

**Mark G. Eramian**
*University of Saskatchewan*

---

## Arrayed Binary Trees

* Representation: an array of tree elements
* Each array location is like a tree node.
* Contents of array location is the contents of the node.

---

### Array Indexing Rules

* Store the root node at array index 1 (index 0 is unused).
* If there is an element at array index `i`, then:

  * The left child of `i` (if it exists) is at index `2i`.
  * The right child of `i` (if it exists) is at index `2i + 1`.
  * The parent of `i` is at index `i/2` (integer division).

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9  6  8  1  0 15 11  -

Parent of index 4: 4/2 = 2
Left child of index 4: 2 × 4 = 8
Right child of index 4: 2 × 4 + 1 = 9
```

---

### Example Tree Representation

**Array Form:**

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9  6  8  1  0 15 11  -
```

**Tree Form:**

```
          2
        /   \
       9     6
      / \   / \
     8   1 0  15
    /
   11
```

---

### Conditions for Array Representation

Binary trees representable by arrays must satisfy:

* All levels except possibly the lowest are full.
* All nodes in the lowest level are as far to the left as possible.

Offsets containing data items must be contiguous.

---

### Identifying Array-Represented Trees

**First array (valid):**

```
        7
      /   \
     9     16
    / \    /
   8   1  10
```

**Second array (invalid):** Contains item at index 0.

**Third array (invalid):** Nodes not in leftmost position:

```
     17
    /  \
   6    15
      
 (node 6 has only one right child)
```

**Fourth array (valid):**

```
  33
```

---

### Checking Array Representation Possibility

**Valid example:**

Array:

```
Index:  0  1  2  3  4  5  6  7  8  9 10
Value:  -  2  9  6  6 21 30  5 14 67 22
```

Tree:

```
          2
       /     \
      9       6
     / \     / \
    6  21   30  5
   / \   /
 14  67 22
```

**Invalid example:** Bottom nodes not leftmost.

---

### More Examples

**Top-left tree (valid):**

```
   2
  / \
 30  5
```

Array:

```
Index:  0  1  2  3
Value:  -  2 30  5
```

**Top-right tree (valid):**

```
 15
```

Array:

```
Index:  0  1
Value:  - 15
```

**Bottom tree (invalid):** Bottom nodes not leftmost.

---

## Insertion Algorithm

* Inserted elements always go at the end of the array.
* Inserted elements occupy the leftmost open position on the bottom-most level.

**Insertion Example:**

Original Array:

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9  6  8  1  0 15 11  -
```

After inserting `42`:

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9  6  8  1  0 15 11 42
```

Tree:

```
         2
       /   \
      9     6
     / \   / \
    8   1 0  15
   / \
  11  42
```

---

## Deletion Algorithm

* Erase deleted item in array.
* Move the last element into the vacated position if the array becomes non-contiguous.

**Deletion Example:**

Before deletion:

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9  6  8  1  0 15 11 42
```

After deleting item at index 3 (`6`):

```
Index:  0  1  2  3  4  5  6  7  8  9
Value:  -  2  9 42  8  1  0 15 11  -
```

Tree:

```
         2
       /   \
      9     42
     / \   / \
    8   1 0  15
   /
  11
```

---

*(Notes by Mark G. Eramian, University of Saskatchewan)*
