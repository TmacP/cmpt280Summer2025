# Timing Analysis of Recursive Algorithms

This document explains how to compute recursive timing analysis based on the provided slides and demonstrates examples using Java code.

---

## General Formula for Recursive Timing

Given a recursive method $p$:

- $T_p$ = total time for method $p$  
- $TR_p(j)$ = time for the $j$-th recursive call

Then:

$$
T_p = \sum_{j=1}^{k} TR_p(j)
$$

where $k$ is the total number of recursive calls.

If $TR_p(j)$ is constant, then:

$$
T_p = k \cdot TR_p
$$

---

## Examples from Java Code (`LinkedSimpleTree280.java`)

We'll analyze timing complexity for traversal methods based on a typical binary tree traversal method structure.

### Exercise 1: Pre-order Traversal

Pseudocode:

```text
preOrder(node):
    if node != null:
        visit(node)
        preOrder(node.left)
        preOrder(node.right)
```

**Timing Analysis**

- $TR_p$ (time per recursive call) is $O(1)$.
- Every node is visited exactly once.

**Complexity**

$$
T_p = n \cdot O(1) = O(n)
$$

---

### Exercise 2: In-order Traversal

Pseudocode:

```text
inOrder(node):
    if node != null:
        inOrder(node.left)
        visit(node)
        inOrder(node.right)
```

**Timing Analysis**

- Each node visited exactly once.
- $TR_p = O(1)$.

**Complexity**

$$
T_p = n \cdot O(1) = O(n)
$$

---

### Exercise 3: Post-order Traversal

Pseudocode:

```text
postOrder(node):
    if node != null:
        postOrder(node.left)
        postOrder(node.right)
        visit(node)
```

**Timing Analysis**

- Each node visited exactly once.
- $TR_p = O(1)$.

**Complexity**

$$
T_p = n \cdot O(1) = O(n)
$$

---

### Exercise 4: Count Nodes (Post-order)

Pseudocode:

```text
countNodes(node):
    if node == null:
        return 0
    else:
        leftCount = countNodes(node.left)
        rightCount = countNodes(node.right)
        return 1 + leftCount + rightCount
```

**Timing Analysis**

- Each node is visited exactly once.
- $TR_p = O(1)$.

**Complexity**

$$
T_p = n \cdot O(1) = O(n)
$$

---

### Exercise 5: Height (Post-order)

Pseudocode:

```text
height(node):
    if node == null:
        return -1
    else:
        leftHeight = height(node.left)
        rightHeight = height(node.right)
        return 1 + max(leftHeight, rightHeight)
```

**Timing Analysis**

- Each node visited exactly once.
- $TR_p = O(1)$.

**Complexity**

$$
T_p = n \cdot O(1) = O(n)
$$

---

### Exercise 6: Level-order Traversal (Non-recursive)

Level-order traversal typically uses a queue (BFS):

```text
levelOrder(node):
    queue.enqueue(node)
    while queue not empty:
        current = queue.dequeue()
        visit(current)
        if current.left != null: queue.enqueue(current.left)
        if current.right != null: queue.enqueue(current.right)
```

**Timing Analysis**

- Each node enqueued and dequeued exactly once.
- $O(1)$ per enqueue/dequeue.

**Complexity**

$$
T_p = O(n)
$$

---

## Summary of Complexity

| Exercise | Method                | Complexity |
|----------|------------------------|------------|
| 1        | Pre-order traversal    | $O(n)$     |
| 2        | In-order traversal     | $O(n)$     |
| 3        | Post-order traversal   | $O(n)$     |
| 4        | Count Nodes            | $O(n)$     |
| 5        | Height                 | $O(n)$     |
| 6        | Level-order traversal  | $O(n)$     |
